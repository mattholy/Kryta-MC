import { isVNode as _isVNode } from "vue";
import { createVNode as _createVNode } from "vue";

function _newArrowCheck(innerThis, boundThis) { if (innerThis !== boundThis) { throw new TypeError("Cannot instantiate an arrow function"); } }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

import { defineComponent, Teleport, Transition, vShow, withDirectives } from 'vue';
import PropTypes, { getSlot, tuple, getEvents, getSlotContent } from '../utils/props';
import tools from '../utils/tools';

function _isSlot(s) {
  return typeof s === 'function' || Object.prototype.toString.call(s) === '[object Object]' && !_isVNode(s);
}

export default defineComponent({
  name: 'MiTooltip',
  inheritAttrs: false,
  props: {
    title: PropTypes.any,
    visible: PropTypes.bool,
    placement: PropTypes.oneOf(tuple('top', 'topLeft', 'topRight', 'top-left', 'top-right', 'left', 'leftTop', 'leftBottom', 'left-top', 'left-bottom', 'bottom', 'bottomLeft', 'bottomRight', 'bottom-left', 'bottom-right', 'right', 'rightTop', 'rightBottom', 'right-top', 'right-bottom')).def('top'),
    trigger: PropTypes.oneOf(tuple('hover', 'click', 'focus', 'contextmenu')).def('hover'),
    animation: PropTypes.oneOf(tuple('scale', 'newspaper', 'sticky', 'sign', 'flip', 'flip-horizontal', 'flip-vertical', 'shake')).def('scale'),
    animationDuration: PropTypes.number,
    className: PropTypes.string,
    forceRender: PropTypes.bool.def(false),
    delayShow: PropTypes.number.def(0),
    delayHide: PropTypes.number.def(0),
    autoAdjust: PropTypes.bool.def(true),
    container: PropTypes.oneOfType([PropTypes.func, PropTypes.string, PropTypes.object]),
    destroy: PropTypes.bool.def(false),
    bgColor: PropTypes.string,
    textColor: PropTypes.string
  },
  watch: {
    visible: function visible(val) {
      this.show = val;
    }
  },
  data: function data() {
    return {
      id: "mi-".concat(tools.uid()),
      prefixCls: 'mi-tooltip',
      originEvents: {},
      show: this.$props.visible,
      position: {},
      direction: this.$props.placement,
      offset: 16,
      clickOutside: null,
      _container: null,
      _component: null
    };
  },
  methods: {
    getContainer: function getContainer() {
      var type = _typeof(this.container);

      if (type === 'function') return this.container();

      if (type === 'string') {
        var temp = this.container;
        if (temp.indexOf('#') === -1) temp = "#".concat(temp);
        return document.querySelector(temp);
      }

      if (type === 'object' && this.container instanceof window.HTMLElement) return this.container;
      return document.body;
    },
    createContainer: function createContainer() {
      this._container = this.getContainer();
      this.$forceUpdate();
    },
    removeContainer: function removeContainer() {
      this._container = null;
      this._component = null;
    },
    saveContainer: function saveContainer(elem) {
      this._component = elem;
    },
    onMouseEnter: function onMouseEnter(e) {
      this.fireEvents('onMouseEnter', e);
      this.delayPopupVisible(true, this.delayShow, e);
    },
    onMouseLeave: function onMouseLeave(e) {
      this.fireEvents('onMouseLeave', e);
      this.delayPopupVisible(false, this.delayHide);
    },
    onMouseDown: function onMouseDown(e) {
      this.fireEvents('onMouseDown', e);
    },
    onClick: function onClick(e) {
      this.fireEvents('onClick', e);
      if (e && e.preventDefault) e.preventDefault();
      if (e && e.domEvent) e.domEvent.preventDefault();
      var visible = !this.show;
      this.delayPopupVisible(visible, visible ? this.delayShow : this.delayHide, e !== null && e !== void 0 ? e : null);
    },
    onTouchStart: function onTouchStart(e) {
      this.fireEvents('onTouchstart', e);
    },
    onFocus: function onFocus(e) {
      this.fireEvents('onFocus', e);
      this.delayPopupVisible(true, this.delayShow, e);
    },
    onBlur: function onBlur(e) {
      this.fireEvents('onBlur', e);
      this.delayPopupVisible(false, this.delayHide);
    },
    fireEvents: function fireEvents(type, e) {
      if (this.originEvents[type]) this.originEvents[type](e);
      var event = this.$props[type] || this.$attrs[type];
      if (event) event(e);
    },
    onContextmenu: function onContextmenu(e) {
      if (e && e.preventDefault) e.preventDefault();
      if (e && e.domEvent) e.domEvent.preventDefault();
      this.fireEvents('onContextmenu', e);
      var visible = !this.show;
      this.delayPopupVisible(visible, visible ? this.delayShow : this.delayHide, e !== null && e !== void 0 ? e : null);
    },
    onDocumentClick: function onDocumentClick(e) {
      var target = e.target;
      var root = tools.findDOMNode(this);
      if (root && !root.contains(target)) this.delayPopupVisible(false, this.delayHide);
    },
    popupVisible: function popupVisible(_popupVisible, event) {
      var _this = this;

      this.clearDelayTimer();
      this.show = _popupVisible;

      if (event) {
        this.$nextTick(function () {
          _newArrowCheck(this, _this);

          var elem = this.$refs["".concat(this.prefixCls, "-content")];
          var width = elem.offsetWidth;
          var height = elem.offsetHeight;
          var target = event.target;
          var targetWidth = target.offsetWidth;
          var targetHeight = target.offsetHeight;
          var halfWidth = Math.round(targetWidth / 2 * 100) / 100;
          var halfHeight = Math.round(targetHeight / 2 * 100) / 100;
          var offsetX = event.offsetX || 0;
          var offsetY = event.offsetY || 0;
          var pageX = event.pageX || tools.getElementActualTopLeft(target, 'left');
          var pageY = event.pageY || tools.getElementActualTopLeft(target);
          var x = pageX + (halfWidth - offsetX) - Math.round(width / 2 * 100) / 100;
          var y = pageY - offsetY - height - this.offset;
          var leftX = pageX - offsetX - width - this.offset;
          var rightX = pageX + targetWidth - offsetX + this.offset;
          var bottomY = pageY - offsetY + targetHeight + this.offset;
          if (this.autoAdjust) this.autoAdjustPlacement(target, elem);

          switch (this.direction) {
            case 'topLeft':
            case 'top-left':
              x = pageX - offsetX;
              break;

            case 'topRight':
            case 'top-right':
              x = pageX + (targetWidth - offsetX) - width;
              break;

            case 'leftTop':
            case 'left-top':
              x = leftX;
              y = pageY - offsetY;
              break;

            case 'left':
              x = leftX;
              y = pageY + (halfHeight - offsetY) - Math.round(height / 2 * 100) / 100;
              break;

            case 'leftBottom':
            case 'left-bottom':
              x = leftX;
              y = pageY - offsetY + targetHeight - height;
              break;

            case 'bottomLeft':
            case 'bottom-left':
              x = pageX - offsetX;
              y = bottomY;
              break;

            case 'bottom':
              y = bottomY;
              break;

            case 'bottomRight':
            case 'bottom-right':
              x = pageX - offsetX + targetWidth - width;
              y = bottomY;
              break;

            case 'rightTop':
            case 'right-top':
              x = rightX;
              y = pageY - offsetY;
              break;

            case 'right':
              x = rightX;
              y = pageY + (halfHeight - offsetY) - Math.round(height / 2 * 100) / 100;
              break;

            case 'rightBottom':
            case 'right-bottom':
              x = rightX;
              y = pageY - offsetY + targetHeight - height;
              break;
          }

          this.position = {
            x: x,
            y: y
          };
        }.bind(this));
      }
    },
    delayPopupVisible: function delayPopupVisible(visible, time, event) {
      var _this2 = this;

      var delay = time * 1000;
      this.clearDelayTimer();

      if (delay) {
        this.delayTimer = tools.createRequestAnimationFrame(function () {
          _newArrowCheck(this, _this2);

          this.popupVisible(visible, event);
          this.clearDelayTimer();
        }.bind(this), delay);
      } else this.popupVisible(visible, event);
    },
    clearDelayTimer: function clearDelayTimer() {
      if (this.delayTimer) {
        tools.cancelRequestAnimationFrame(this.delayTimer);
        this.delayTimer = null;
      }
    },
    autoAdjustPlacement: function autoAdjustPlacement(targetElem, contentElem) {
      if (targetElem && contentElem) {
        var direction = this.direction;
        var width = document.body.clientWidth;
        var height = document.body.clientHeight;
        var targetWidth = targetElem.offsetWidth;
        var targetHeight = targetElem.offsetHeight;
        var contentWidth = contentElem.offsetWidth;
        var contentHeight = contentElem.offsetHeight;
        var top = tools.getElementActualTopLeft(targetElem);
        var left = tools.getElementActualTopLeft(targetElem, 'left');
        var offset = {
          top: top,
          left: left,
          right: width - targetWidth - left,
          bottom: height - targetHeight - top
        };

        switch (this.placement) {
          case 'left':
          case 'leftTop':
          case 'left-top':
          case 'leftBottom':
          case 'left-bottom':
            if (offset.left < contentWidth && offset.right > offset.left) {
              if (this.direction === 'left') direction = 'right';
              if (this.direction === 'leftTop' || this.direction === 'left-top') direction = 'right-top';
              if (this.direction === 'leftBottom' || this.direction === 'left-bottom') direction = 'right-bottom';
            } else direction = this.placement;

            break;

          case 'right':
          case 'rightTop':
          case 'right-top':
          case 'rightBottom':
          case 'right-bottom':
            if (offset.right < contentWidth && offset.left > offset.right) {
              if (this.direction === 'right') direction = 'left';
              if (this.direction === 'rightTop' || this.direction === 'right-top') direction = 'left-top';
              if (this.direction === 'rightBottom' || this.direction === 'right-bottom') direction = 'left-bottom';
            } else direction = this.placement;

            break;

          case 'top':
          case 'topLeft':
          case 'top-left':
          case 'topRight':
          case 'top-right':
            if (offset.top < contentHeight && offset.bottom > offset.top) {
              if (this.direction === 'top') direction = 'bottom';
              if (this.direction === 'topLeft' || this.direction === 'top-left') direction = 'bottom-left';
              if (this.direction === 'topRight' || this.direction === 'top-right') direction = 'bottom-right';
            } else direction = this.placement;

            break;

          case 'bottom':
          case 'bottomLeft':
          case 'bottom-left':
          case 'bottomRight':
          case 'bottom-right':
            if (offset.bottom < contentHeight && offset.top > offset.bottom) {
              if (this.direction === 'bottom') direction = 'top';
              if (this.direction === 'bottomLeft' || this.direction === 'bottom-left') direction = 'top-left';
              if (this.direction === 'bottomRight' || this.direction === 'bottom-right') direction = 'top-right';
            } else direction = this.placement;

            break;
        }

        if (direction !== this.direction) this.direction = direction;
      }
    }
  },
  beforeUnmount: function beforeUnmount() {
    this.removeContainer();
  },
  mounted: function mounted() {
    var _this3 = this;

    this.createContainer();

    if (this.forceRender || this.show) {
      this.$nextTick(function () {
        _newArrowCheck(this, _this3);

        var elem = document.getElementById(this.id);

        if (elem) {
          var elemWidth = elem.offsetWidth;
          var elemHeight = elem.offsetHeight;
          var position = {
            x: tools.getElementActualTopLeft(elem, 'left'),
            y: tools.getElementActualTopLeft(elem)
          };
          var content = this.$refs["".concat(this.prefixCls, "-content")];
          var width = content.offsetWidth;
          var height = content.offsetHeight;
          var x = position.x - Math.round((width - elemWidth) / 2 * 100) / 100;
          var y = position.y - (height + this.offset);
          var centerY = position.y + Math.round(elemHeight / 2 * 100) / 100 - Math.round(height / 2 * 100) / 100;
          var bottomY = position.y + elemHeight + this.offset;
          var leftX = position.x - width - this.offset;
          var rightX = position.x + elemWidth + this.offset;
          if (this.autoAdjust) this.autoAdjustPlacement(elem, content);

          switch (this.direction) {
            case 'topLeft':
            case 'top-left':
              x = position.x;
              break;

            case 'topRight':
            case 'top-right':
              x = position.x + elemWidth - width;
              break;

            case 'leftTop':
            case 'left-top':
              x = leftX;
              y = position.y;
              break;

            case 'left':
              x = leftX;
              y = centerY;
              break;

            case 'leftBottom':
            case 'left-bottom':
              x = leftX;
              y = position.y + elemHeight - height;
              break;

            case 'bottomLeft':
            case 'bottom-left':
              x = position.x;
              y = bottomY;
              break;

            case 'bottom':
              y = bottomY;
              break;

            case 'bottomRight':
            case 'bottom-right':
              x = position.x + elemWidth - width;
              y = bottomY;
              break;

            case 'rightTop':
            case 'right-top':
              x = rightX;
              y = position.y;
              break;

            case 'right':
              x = rightX;
              y = centerY;
              break;

            case 'rightBottom':
            case 'right-bottom':
              x = rightX;
              y = position.y + elemHeight - height;
              break;
          }

          this.position = {
            x: x,
            y: y
          };
        }
      }.bind(this));
    }

    if (!this.clickOutside && (this.trigger === 'click' || this.trigger === 'contextmenu')) this.clickOutside = tools.on(document.body, 'mousedown', this.onDocumentClick);
  },
  render: function render() {
    var _this4 = this;

    var children = tools.filterEmpty(getSlot(this));
    var child = children[0];
    this.originEvents = getEvents(child);
    var newChildProps = {
      key: 'trigger',
      id: this.id
    };

    switch (this.trigger) {
      case 'hover':
        newChildProps.onMouseEnter = this.onMouseEnter;
        newChildProps.onMouseLeave = this.onMouseLeave;
        break;

      case 'click':
        newChildProps.onClick = this.onClick;
        newChildProps.onMousedown = this.onMouseDown;
        newChildProps.onTouchstart = this.onTouchStart;
        break;

      case 'focus':
        newChildProps.onFocus = this.onFocus;
        newChildProps.onBlur = this.onBlur;
        break;

      case 'contextmenu':
        newChildProps.onContextmenu = this.onContextmenu;
        break;
    }

    var newChild = tools.cloneElement(child, newChildProps);
    var teleport;

    if (this._container && (this.show || this.forceRender || this._component)) {
      var _slot, _slot2;

      var _this$bgColor, _this$bgColor2, _this$textColor;

      var style = {
        left: "".concat(this.position.x, "px"),
        top: "".concat(this.position.y, "px"),
        transitionDuration: this.animationDuration ? "".concat(this.animationDuration, "s") : null
      };
      var bgColor = {
        background: (_this$bgColor = this.bgColor) !== null && _this$bgColor !== void 0 ? _this$bgColor : null
      };
      var boxShadow = {
        boxShadow: this.bgColor ? "0 0 6px ".concat(this.bgColor) : null
      };
      var arrowColor = {
        background: (_this$bgColor2 = this.bgColor) !== null && _this$bgColor2 !== void 0 ? _this$bgColor2 : null,
        boxShadow: this.bgColor ? "0 0 4px ".concat(this.bgColor) : null
      };
      var textColor = {
        color: (_this$textColor = this.textColor) !== null && _this$textColor !== void 0 ? _this$textColor : null
      };

      var title = _createVNode("div", {
        "style": textColor
      }, [getSlotContent(this, 'title')]);

      teleport = _createVNode(Teleport, {
        "to": this._container,
        "ref": this.saveContainer
      }, _isSlot(_slot2 = _createVNode("div", {
        "ref": this.prefixCls,
        "class": this.prefixCls + "".concat(this.className ? " ".concat(this.className) : '')
      }, [_createVNode(Transition, {
        "key": "tooltip",
        "name": "mi-".concat(this.animation),
        "appear": true
      }, _isSlot(_slot = withDirectives(_createVNode("div", {
        "class": "".concat(this.prefixCls, "-").concat(this.direction),
        "style": this._component ? style : null
      }, [_createVNode("div", {
        "class": "".concat(this.prefixCls, "-content"),
        "ref": "".concat(this.prefixCls, "-content"),
        "style": boxShadow
      }, [_createVNode("div", {
        "class": "".concat(this.prefixCls, "-arrow")
      }, [_createVNode("span", {
        "class": "".concat(this.prefixCls, "-arrow-inner"),
        "style": arrowColor
      }, null)]), _createVNode("div", {
        "class": "".concat(this.prefixCls, "-inner"),
        "style": bgColor
      }, _isSlot(title) ? title : {
        default: function _default() {
          _newArrowCheck(this, _this4);

          return [title];
        }.bind(this)
      })])]), [[vShow, this.show]])) ? _slot : {
        default: function _default() {
          _newArrowCheck(this, _this4);

          return [_slot];
        }.bind(this)
      })])) ? _slot2 : {
        default: function _default() {
          _newArrowCheck(this, _this4);

          return [_slot2];
        }.bind(this)
      });
    }

    return [teleport, newChild];
  }
});