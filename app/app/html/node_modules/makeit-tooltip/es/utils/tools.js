function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _newArrowCheck(innerThis, boundThis) { if (innerThis !== boundThis) { throw new TypeError("Cannot instantiate an arrow function"); } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

import { Fragment, Comment, Text, cloneVNode } from 'vue';
var availablePrefixs = ['moz', 'ms', 'webkit'];

var MiTools = /*#__PURE__*/function () {
  function MiTools() {
    _classCallCheck(this, MiTools);
  }

  _createClass(MiTools, [{
    key: "isMobile",

    /**
     * Whether it is a mobile phone.
     * @returns {boolean}
     */
    value: function isMobile() {
      var agent = navigator.userAgent,
          agents = ['Android', 'iPhone', 'SymbianOS', 'Windows Phone', 'iPad', 'iPod'];
      var mobile = false;

      for (var i = 0, len = agents.length; i < len; i++) {
        if (agent.indexOf(agents[i]) > 0) {
          mobile = true;
          break;
        }
      }

      return mobile;
    }
    /**
     * Clone Node.
     * @param vNode
     * @param nodeProps
     * @param override
     * @param mergeRef
     */

  }, {
    key: "cloneElement",
    value: function cloneElement(vNode) {
      var nodeProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var override = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var mergeRef = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var elem = vNode;

      if (Array.isArray(vNode)) {
        elem = this.filterEmpty(vNode)[0];
      }

      if (!elem) return null;
      var node = cloneVNode(elem, nodeProps, mergeRef);
      node.props = override ? _objectSpread(_objectSpread({}, node.props), nodeProps) : node.props;
      return node;
    }
    /**
     * Whether the element is empty.
     * @param elem
     */

  }, {
    key: "isEmptyElement",
    value: function isEmptyElement(elem) {
      return elem.type === Comment || elem.type === Fragment && elem.children.length === 0 || elem.type === Text && elem.children.trim() == '';
    }
    /**
     * Whether the value is valid.
     * @param value
     */

  }, {
    key: "isValid",
    value: function isValid(value) {
      return value !== undefined && value !== null && value !== '';
    }
    /**
     * Filter the empty element.
     * @param children
     */

  }, {
    key: "filterEmpty",
    value: function filterEmpty() {
      var _this = this;

      var children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var res = [];
      children.forEach(function (child) {
        _newArrowCheck(this, _this);

        if (Array.isArray(child)) {
          res.push.apply(res, _toConsumableArray(child));
        } else if (child.type === Fragment) {
          res.push.apply(res, _toConsumableArray(child.children));
        } else {
          res.push(child);
        }
      }.bind(this));
      return res.filter(function (c) {
        _newArrowCheck(this, _this);

        return !this.isEmptyElement(c);
      }.bind(this));
    }
    /**
     * Request Animation Polyfill.
     */

  }, {
    key: "requestAnimationFramePolyfill",
    value: function requestAnimationFramePolyfill() {
      var lastTime = 0;
      return function (callback) {
        var currTime = new Date().getTime();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = window.setTimeout(function () {
          callback(currTime + timeToCall);
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
      };
    }
    /**
     * Get Request Animation Frame.
     */

  }, {
    key: "getRequestAnimationFrame",
    value: function getRequestAnimationFrame() {
      var _this2 = this;

      if (typeof window === 'undefined') return function () {
        _newArrowCheck(this, _this2);
      }.bind(this);
      if (window.requestAnimationFrame) return window.requestAnimationFrame.bind(window);
      var prefix = availablePrefixs.filter(function (key) {
        _newArrowCheck(this, _this2);

        return "".concat(key, "RequestAnimationFrame") in window;
      }.bind(this))[0];
      return prefix ? window["".concat(prefix, "RequestAnimationFrame")] : this.requestAnimationFramePolyfill();
    }
    /**
     * Request Animation.
     * @param callback
     * @param delay
     */

  }, {
    key: "createRequestAnimationFrame",
    value: function createRequestAnimationFrame(callback, delay) {
      var _this3 = this;

      var start = Date.now();
      var graf = this.getRequestAnimationFrame();

      var _timeout = function timeout() {
        _newArrowCheck(this, _this3);

        if (Date.now() - start >= delay) callback.call();else frame.id = graf(_timeout);
      }.bind(this);

      var frame = {
        id: graf(_timeout)
      };
      return frame;
    }
    /**
     * Cancel request animation.
     * @param id
     */

  }, {
    key: "cancelRequestAnimationFrame",
    value: function cancelRequestAnimationFrame(id) {
      var _this4 = this;

      if (typeof window === 'undefined') return null;
      if (window.cancelAnimationFrame) return window.cancelAnimationFrame(id);
      var prefix = availablePrefixs.filter(function (key) {
        _newArrowCheck(this, _this4);

        return "".concat(key, "CancelAnimationFrame") in window || "".concat(key, "CancelRequestAnimationFrame") in window;
      }.bind(this))[0];
      return prefix ? (window["".concat(prefix, "CancelAnimationFrame")] || window["".concat(prefix, "CancelRequestAnimationFrame")]).call(this, id) : clearTimeout(id);
    }
  }, {
    key: "random",
    value: function random() {
      return ((1 + Math.random()) * 0x10000 | 0).toString(16).substring(1);
    }
    /**
     * Generate unique string.
     * @param upper
     * @returns {string}
     */

  }, {
    key: "uid",
    value: function uid() {
      var upper = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var prefix = arguments.length > 1 ? arguments[1] : undefined;
      var str = (this.random() + this.random() + this.random() + this.random() + this.random() + this.random() + this.random() + this.random()).toLocaleUpperCase();
      if (prefix) str = prefix + str;
      return upper ? str.toUpperCase() : str.toLowerCase();
    }
    /**
     * Event binding.
     * @param element
     * @param event
     * @param listener
     * @param useCapture
     */

  }, {
    key: "on",
    value: function on(element, event, listener) {
      var useCapture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      if (!!document.addEventListener) {
        if (element && event && listener) element.addEventListener(event, listener, useCapture);
      } else {
        if (element && event && listener) element.attachEvent("on".concat(event), listener);
      }
    }
    /**
     * Event unbind.
     * @param element
     * @param event
     * @param listener
     * @param useCapture
     */

  }, {
    key: "off",
    value: function off(element, event, listener) {
      var useCapture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      if (!!document.addEventListener) {
        if (element && event && listener) element.removeEventListener(event, listener, useCapture);
      } else {
        if (element && event && listener) element.detachEvent("on".concat(event), listener);
      }
    }
  }, {
    key: "findDOMNode",
    value: function findDOMNode(instance) {
      var node = instance && (instance.$el || instance);

      while (node && !node.tagName) {
        node = node.nextSibling;
      }

      return node;
    }
  }, {
    key: "getElementActualTopLeft",
    value: function getElementActualTopLeft(el) {
      var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';
      var actual = pos === 'left' ? el.offsetLeft : el.offsetTop;
      var current = el.offsetParent;

      while (current !== null) {
        actual += pos === 'left' ? current.offsetLeft : current.offsetTop;
        current = current.offsetParent;
      }

      return actual;
    }
  }]);

  return MiTools;
}();

export default new MiTools();